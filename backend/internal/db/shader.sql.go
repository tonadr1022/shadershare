// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: shader.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addShaderToPlaylist = `-- name: AddShaderToPlaylist :exec
INSERT INTO shader_playlist_junction (playlist_id, shader_id,user_id)
SELECT $1, $2, $3
FROM shader_playlists p, shaders s
WHERE p.id = $1
  AND s.id = $2
  AND p.user_id = $3
  AND s.user_id = $3 ON CONFLICT DO NOTHING
`

type AddShaderToPlaylistParams struct {
	PlaylistID uuid.UUID
	ShaderID   uuid.UUID
	UserID     uuid.UUID
}

func (q *Queries) AddShaderToPlaylist(ctx context.Context, arg AddShaderToPlaylistParams) error {
	_, err := q.db.Exec(ctx, addShaderToPlaylist, arg.PlaylistID, arg.ShaderID, arg.UserID)
	return err
}

const addShaderToPlaylistBulk = `-- name: AddShaderToPlaylistBulk :exec
INSERT INTO shader_playlist_junction (playlist_id, shader_id, user_id)
SELECT $1::uuid, s.id, $2::uuid
FROM unnest($3::uuid[]) AS s(id)
WHERE EXISTS (
    SELECT 1
    FROM shader_playlists p_check
    WHERE p_check.id = $1::uuid
      AND p_check.user_id = $2
)
AND EXISTS (
    SELECT 1
    FROM shaders s_check
    WHERE s_check.id = s.id
      AND s_check.user_id = $2
)
`

type AddShaderToPlaylistBulkParams struct {
	PlaylistID uuid.UUID
	UserID     uuid.UUID
	ShaderIds  []uuid.UUID
}

func (q *Queries) AddShaderToPlaylistBulk(ctx context.Context, arg AddShaderToPlaylistBulkParams) error {
	_, err := q.db.Exec(ctx, addShaderToPlaylistBulk, arg.PlaylistID, arg.UserID, arg.ShaderIds)
	return err
}

const countShaders = `-- name: CountShaders :one
SELECT COUNT(*)
FROM shaders
WHERE
    (user_id = $1 OR $1 IS NULL) AND
    (access_level = $2 OR $2 IS NULL) AND
  (
  $3::text IS NULL OR $3::text = '' OR
  textsearchable_index_col @@ plainto_tsquery($3::text)
  )
`

type CountShadersParams struct {
	UserID      pgtype.UUID
	AccessLevel pgtype.Int2
	Query       pgtype.Text
}

func (q *Queries) CountShaders(ctx context.Context, arg CountShadersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countShaders, arg.UserID, arg.AccessLevel, arg.Query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createShader = `-- name: CreateShader :one
INSERT INTO shaders (
    title, description, user_id, preview_img_url, access_level, flags, tags, forked_from
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8::uuid
)
ON CONFLICT (title) DO NOTHING
RETURNING id, title, description, user_id, 
    access_level, preview_img_url, created_at, 
    updated_at, flags, tags
`

type CreateShaderParams struct {
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	PreviewImgUrl pgtype.Text
	AccessLevel   int16
	Flags         int32
	Tags          pgtype.Text
	ForkedFrom    pgtype.UUID
}

type CreateShaderRow struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
}

func (q *Queries) CreateShader(ctx context.Context, arg CreateShaderParams) (CreateShaderRow, error) {
	row := q.db.QueryRow(ctx, createShader,
		arg.Title,
		arg.Description,
		arg.UserID,
		arg.PreviewImgUrl,
		arg.AccessLevel,
		arg.Flags,
		arg.Tags,
		arg.ForkedFrom,
	)
	var i CreateShaderRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.AccessLevel,
		&i.PreviewImgUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Flags,
		&i.Tags,
	)
	return i, err
}

const createShaderPlaylist = `-- name: CreateShaderPlaylist :one
INSERT INTO shader_playlists (
    title, access_level, description, user_id, tags
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, title, access_level, description, user_id, tags, created_at, updated_at
`

type CreateShaderPlaylistParams struct {
	Title       string
	AccessLevel int16
	Description pgtype.Text
	UserID      uuid.UUID
	Tags        []string
}

func (q *Queries) CreateShaderPlaylist(ctx context.Context, arg CreateShaderPlaylistParams) (ShaderPlaylist, error) {
	row := q.db.QueryRow(ctx, createShaderPlaylist,
		arg.Title,
		arg.AccessLevel,
		arg.Description,
		arg.UserID,
		arg.Tags,
	)
	var i ShaderPlaylist
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AccessLevel,
		&i.Description,
		&i.UserID,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteShader = `-- name: DeleteShader :one
DELETE FROM shaders
WHERE id = $1 AND user_id = $2 RETURNING 
id, title, description, user_id, 
    access_level, preview_img_url, created_at, 
    updated_at, flags, tags
`

type DeleteShaderParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

type DeleteShaderRow struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
}

func (q *Queries) DeleteShader(ctx context.Context, arg DeleteShaderParams) (DeleteShaderRow, error) {
	row := q.db.QueryRow(ctx, deleteShader, arg.ID, arg.UserID)
	var i DeleteShaderRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.AccessLevel,
		&i.PreviewImgUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Flags,
		&i.Tags,
	)
	return i, err
}

const deleteShaderPlaylist = `-- name: DeleteShaderPlaylist :exec
DELETE FROM shader_playlists
WHERE id = $1 AND user_id = $2
`

type DeleteShaderPlaylistParams struct {
	ID     uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) DeleteShaderPlaylist(ctx context.Context, arg DeleteShaderPlaylistParams) error {
	_, err := q.db.Exec(ctx, deleteShaderPlaylist, arg.ID, arg.UserID)
	return err
}

const deleteShadersFromPlaylist = `-- name: DeleteShadersFromPlaylist :exec
DELETE FROM shader_playlist_junction
WHERE shader_id = ANY($1)
AND playlist_id = $2::uuid
`

type DeleteShadersFromPlaylistParams struct {
	ShaderIds  []uuid.UUID
	PlaylistID uuid.UUID
}

func (q *Queries) DeleteShadersFromPlaylist(ctx context.Context, arg DeleteShadersFromPlaylistParams) error {
	_, err := q.db.Exec(ctx, deleteShadersFromPlaylist, arg.ShaderIds, arg.PlaylistID)
	return err
}

const getPlaylistWithShaders = `-- name: GetPlaylistWithShaders :one
SELECT p.id, p.title, p.access_level, p.description, p.user_id, p.tags, p.created_at, p.updated_at,
    COALESCE(json_agg(s.*), '[]')::json AS shaders
FROM shader_playlists p
LEFT JOIN shader_playlist_junction j 
ON j.playlist_id = p.id
LEFT JOIN shaders s ON s.id = j.shader_id
WHERE p.id = $1::uuid GROUP BY p.id LIMIT 1
`

type GetPlaylistWithShadersRow struct {
	ShaderPlaylist ShaderPlaylist
	Shaders        []byte
}

func (q *Queries) GetPlaylistWithShaders(ctx context.Context, id uuid.UUID) (GetPlaylistWithShadersRow, error) {
	row := q.db.QueryRow(ctx, getPlaylistWithShaders, id)
	var i GetPlaylistWithShadersRow
	err := row.Scan(
		&i.ShaderPlaylist.ID,
		&i.ShaderPlaylist.Title,
		&i.ShaderPlaylist.AccessLevel,
		&i.ShaderPlaylist.Description,
		&i.ShaderPlaylist.UserID,
		&i.ShaderPlaylist.Tags,
		&i.ShaderPlaylist.CreatedAt,
		&i.ShaderPlaylist.UpdatedAt,
		&i.Shaders,
	)
	return i, err
}

const getPlaylistWithShadersWithUser = `-- name: GetPlaylistWithShadersWithUser :one
SELECT p.id, p.title, p.access_level, p.description, p.user_id, p.tags, p.created_at, p.updated_at, u.username,
    COALESCE(json_agg(s.*), '[]')::json AS shaders,
    COUNT(s.*) AS num_shaders
FROM shader_playlists p
LEFT JOIN users u ON u.id = p.user_id
LEFT JOIN shader_playlist_junction j 
ON j.playlist_id = p.id
LEFT JOIN shaders s ON s.id = j.shader_id
WHERE p.id = $1::uuid GROUP BY p.id, u.username LIMIT 1
`

type GetPlaylistWithShadersWithUserRow struct {
	ShaderPlaylist ShaderPlaylist
	Username       pgtype.Text
	Shaders        []byte
	NumShaders     int64
}

func (q *Queries) GetPlaylistWithShadersWithUser(ctx context.Context, id uuid.UUID) (GetPlaylistWithShadersWithUserRow, error) {
	row := q.db.QueryRow(ctx, getPlaylistWithShadersWithUser, id)
	var i GetPlaylistWithShadersWithUserRow
	err := row.Scan(
		&i.ShaderPlaylist.ID,
		&i.ShaderPlaylist.Title,
		&i.ShaderPlaylist.AccessLevel,
		&i.ShaderPlaylist.Description,
		&i.ShaderPlaylist.UserID,
		&i.ShaderPlaylist.Tags,
		&i.ShaderPlaylist.CreatedAt,
		&i.ShaderPlaylist.UpdatedAt,
		&i.Username,
		&i.Shaders,
		&i.NumShaders,
	)
	return i, err
}

const getShader = `-- name: GetShader :one
SELECT id, title, description, user_id, 
    access_level, preview_img_url, created_at, 
    updated_at, flags, tags, forked_from
FROM full_shader_view
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetShader(ctx context.Context, id uuid.UUID) (FullShaderView, error) {
	row := q.db.QueryRow(ctx, getShader, id)
	var i FullShaderView
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.AccessLevel,
		&i.PreviewImgUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Flags,
		&i.Tags,
		&i.ForkedFrom,
	)
	return i, err
}

const getShaderDetailed = `-- name: GetShaderDetailed :one
SELECT sd.id, sd.title, sd.description, sd.user_id, 
    sd.access_level, sd.preview_img_url, sd.created_at, 
    sd.updated_at, sd.flags, sd.tags, sd.outputs, sd.forked_from,
    p.title AS parent_title
FROM shader_details sd 
LEFT JOIN shaders p ON sd.forked_from = p.id 
WHERE sd.id = $1
`

type GetShaderDetailedRow struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
	Outputs       []byte
	ForkedFrom    pgtype.UUID
	ParentTitle   pgtype.Text
}

func (q *Queries) GetShaderDetailed(ctx context.Context, id uuid.UUID) (GetShaderDetailedRow, error) {
	row := q.db.QueryRow(ctx, getShaderDetailed, id)
	var i GetShaderDetailedRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.AccessLevel,
		&i.PreviewImgUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Flags,
		&i.Tags,
		&i.Outputs,
		&i.ForkedFrom,
		&i.ParentTitle,
	)
	return i, err
}

const getShaderDetailedWithUser = `-- name: GetShaderDetailedWithUser :one
SELECT sd.id, sd.title, sd.description, sd.user_id, 
    sd.access_level, sd.preview_img_url, sd.created_at, 
    sd.updated_at, sd.flags, sd.tags, sd.outputs,sd.username,sd.forked_from,
    p.title AS parent_title
FROM shader_details_with_user sd
LEFT JOIN shaders p ON sd.forked_from = p.id 
WHERE sd.id = $1
`

type GetShaderDetailedWithUserRow struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
	Outputs       []byte
	Username      string
	ForkedFrom    pgtype.UUID
	ParentTitle   pgtype.Text
}

func (q *Queries) GetShaderDetailedWithUser(ctx context.Context, id uuid.UUID) (GetShaderDetailedWithUserRow, error) {
	row := q.db.QueryRow(ctx, getShaderDetailedWithUser, id)
	var i GetShaderDetailedWithUserRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.AccessLevel,
		&i.PreviewImgUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Flags,
		&i.Tags,
		&i.Outputs,
		&i.Username,
		&i.ForkedFrom,
		&i.ParentTitle,
	)
	return i, err
}

const getShaderPlaylist = `-- name: GetShaderPlaylist :one
SELECT id, title, access_level, description, user_id, tags, created_at, updated_at FROM shader_playlists
WHERE id = $1
`

func (q *Queries) GetShaderPlaylist(ctx context.Context, id uuid.UUID) (ShaderPlaylist, error) {
	row := q.db.QueryRow(ctx, getShaderPlaylist, id)
	var i ShaderPlaylist
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.AccessLevel,
		&i.Description,
		&i.UserID,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShaderPlaylistWithUser = `-- name: GetShaderPlaylistWithUser :one
SELECT s.id, s.title, s.access_level, s.description, s.user_id, s.tags, s.created_at, s.updated_at,u.username FROM shader_playlists s 
LEFT JOIN users u ON s.user_id = u.id
WHERE id = $1::uuid
`

type GetShaderPlaylistWithUserRow struct {
	ShaderPlaylist ShaderPlaylist
	Username       pgtype.Text
}

func (q *Queries) GetShaderPlaylistWithUser(ctx context.Context, id uuid.UUID) (GetShaderPlaylistWithUserRow, error) {
	row := q.db.QueryRow(ctx, getShaderPlaylistWithUser, id)
	var i GetShaderPlaylistWithUserRow
	err := row.Scan(
		&i.ShaderPlaylist.ID,
		&i.ShaderPlaylist.Title,
		&i.ShaderPlaylist.AccessLevel,
		&i.ShaderPlaylist.Description,
		&i.ShaderPlaylist.UserID,
		&i.ShaderPlaylist.Tags,
		&i.ShaderPlaylist.CreatedAt,
		&i.ShaderPlaylist.UpdatedAt,
		&i.Username,
	)
	return i, err
}

const getShaderPlaylistWithUserAndCount = `-- name: GetShaderPlaylistWithUserAndCount :one
SELECT p.id, p.title, p.access_level, p.description, p.user_id, p.tags, p.created_at, p.updated_at,u.username, COUNT(j.*) AS num_shaders
FROM shader_playlists p
LEFT JOIN users u ON p.user_id = u.id
LEFT JOIN shader_playlist_junction j 
ON j.playlist_id = p.id
WHERE p.id = $1::uuid  GROUP BY p.id, u.username LIMIT 1
`

type GetShaderPlaylistWithUserAndCountRow struct {
	ShaderPlaylist ShaderPlaylist
	Username       pgtype.Text
	NumShaders     int64
}

func (q *Queries) GetShaderPlaylistWithUserAndCount(ctx context.Context, id uuid.UUID) (GetShaderPlaylistWithUserAndCountRow, error) {
	row := q.db.QueryRow(ctx, getShaderPlaylistWithUserAndCount, id)
	var i GetShaderPlaylistWithUserAndCountRow
	err := row.Scan(
		&i.ShaderPlaylist.ID,
		&i.ShaderPlaylist.Title,
		&i.ShaderPlaylist.AccessLevel,
		&i.ShaderPlaylist.Description,
		&i.ShaderPlaylist.UserID,
		&i.ShaderPlaylist.Tags,
		&i.ShaderPlaylist.CreatedAt,
		&i.ShaderPlaylist.UpdatedAt,
		&i.Username,
		&i.NumShaders,
	)
	return i, err
}

const getShaderWithUser = `-- name: GetShaderWithUser :one
SELECT s.id, s.title, s.description, s.user_id, 
    s.access_level, s.preview_img_url, s.created_at, 
    s.updated_at, s.flags, s.tags, s.username
FROM shader_with_user s
WHERE s.id = $1
`

type GetShaderWithUserRow struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
	Username      string
}

func (q *Queries) GetShaderWithUser(ctx context.Context, id uuid.UUID) (GetShaderWithUserRow, error) {
	row := q.db.QueryRow(ctx, getShaderWithUser, id)
	var i GetShaderWithUserRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.AccessLevel,
		&i.PreviewImgUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Flags,
		&i.Tags,
		&i.Username,
	)
	return i, err
}

const getTopTags = `-- name: GetTopTags :many
WITH tokenized_tags AS (
    SELECT unnest(
            regexp_split_to_array(COALESCE(tags, ''), '\s* \s*')
        ) AS word
    FROM shaders
)
SELECT word,
    COUNT(*) AS frequency
FROM tokenized_tags
GROUP BY word
ORDER BY frequency DESC
OFFSET 1 LIMIT 20
`

type GetTopTagsRow struct {
	Word      interface{}
	Frequency int64
}

func (q *Queries) GetTopTags(ctx context.Context) ([]GetTopTagsRow, error) {
	rows, err := q.db.Query(ctx, getTopTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopTagsRow
	for rows.Next() {
		var i GetTopTagsRow
		if err := rows.Scan(&i.Word, &i.Frequency); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShaderPlaylist = `-- name: ListShaderPlaylist :many
SELECT id, title, access_level, description, user_id, tags, created_at, updated_at FROM shader_playlists
WHERE access_level = $1
LIMIT $3::int
OFFSET $2::int
`

type ListShaderPlaylistParams struct {
	AccessLevel int16
	Off         int32
	Lim         pgtype.Int4
}

func (q *Queries) ListShaderPlaylist(ctx context.Context, arg ListShaderPlaylistParams) ([]ShaderPlaylist, error) {
	rows, err := q.db.Query(ctx, listShaderPlaylist, arg.AccessLevel, arg.Off, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShaderPlaylist
	for rows.Next() {
		var i ShaderPlaylist
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AccessLevel,
			&i.Description,
			&i.UserID,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShaderPlaylistOfUser = `-- name: ListShaderPlaylistOfUser :many
SELECT id, title, access_level, description, user_id, tags, created_at, updated_at FROM shader_playlists
WHERE user_id = $1 AND 
      access_level = $2
LIMIT $4::int
OFFSET $3::int
`

type ListShaderPlaylistOfUserParams struct {
	UserID      uuid.UUID
	AccessLevel int16
	Off         int32
	Lim         pgtype.Int4
}

func (q *Queries) ListShaderPlaylistOfUser(ctx context.Context, arg ListShaderPlaylistOfUserParams) ([]ShaderPlaylist, error) {
	rows, err := q.db.Query(ctx, listShaderPlaylistOfUser,
		arg.UserID,
		arg.AccessLevel,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShaderPlaylist
	for rows.Next() {
		var i ShaderPlaylist
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AccessLevel,
			&i.Description,
			&i.UserID,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShaderPlaylistOfUserWithCount = `-- name: ListShaderPlaylistOfUserWithCount :many
SELECT p.id, p.title, p.access_level, p.description, p.user_id, p.tags, p.created_at, p.updated_at,COUNT(j.*) AS num_shaders FROM shader_playlists p
LEFT JOIN shader_playlist_junction j ON j.playlist_id = p.id
WHERE p.user_id = $1 AND 
      ($2::int2 IS NULL OR p.access_level = $2)
GROUP BY p.id
LIMIT $4::int
OFFSET $3::int
`

type ListShaderPlaylistOfUserWithCountParams struct {
	UserID      uuid.UUID
	AccessLevel pgtype.Int2
	Off         int32
	Lim         pgtype.Int4
}

type ListShaderPlaylistOfUserWithCountRow struct {
	ShaderPlaylist ShaderPlaylist
	NumShaders     int64
}

func (q *Queries) ListShaderPlaylistOfUserWithCount(ctx context.Context, arg ListShaderPlaylistOfUserWithCountParams) ([]ListShaderPlaylistOfUserWithCountRow, error) {
	rows, err := q.db.Query(ctx, listShaderPlaylistOfUserWithCount,
		arg.UserID,
		arg.AccessLevel,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShaderPlaylistOfUserWithCountRow
	for rows.Next() {
		var i ListShaderPlaylistOfUserWithCountRow
		if err := rows.Scan(
			&i.ShaderPlaylist.ID,
			&i.ShaderPlaylist.Title,
			&i.ShaderPlaylist.AccessLevel,
			&i.ShaderPlaylist.Description,
			&i.ShaderPlaylist.UserID,
			&i.ShaderPlaylist.Tags,
			&i.ShaderPlaylist.CreatedAt,
			&i.ShaderPlaylist.UpdatedAt,
			&i.NumShaders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShaders4 = `-- name: ListShaders4 :many

SELECT id, title, description, user_id, 
    access_level, preview_img_url, created_at, 
    updated_at, flags, tags
FROM shaders
WHERE 
  (user_id = $1 OR $1 IS NULL) AND
  ($2::int2 IS NULL OR access_level = $2) AND 
  (
    $3::text IS NULL OR $3::text = '' OR
    (
      -- Search in title and tags combined
      ($4::boolean IS NULL OR $4::boolean = false)
      AND textsearchable_index_col @@ plainto_tsquery('english', $3::text)
      OR
      -- Search only in tags
      ($4::boolean IS NOT NULL AND $4::boolean = true)
      AND tags @@ plainto_tsquery('english', $3::text)
    )
  )
ORDER BY
    CASE WHEN $5::text = 'created_at_asc' THEN created_at END ASC,
    CASE WHEN $5::text = 'created_at_desc' THEN created_at END DESC,
    CASE WHEN $5::text = 'title_asc' THEN title END ASC,
    CASE WHEN $5::text = 'title_desc' THEN title END DESC
LIMIT $7::int
OFFSET $6::int
`

type ListShaders4Params struct {
	UserID         pgtype.UUID
	AccessLevel    pgtype.Int2
	Query          pgtype.Text
	SearchTagsOnly pgtype.Bool
	OrderBy        pgtype.Text
	Off            int32
	Lim            pgtype.Int4
}

type ListShaders4Row struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
}

// -- name: ListShaders :many
// SELECT * FROM shaders
// WHERE access_level = $3
// ORDER BY id LIMIT $1 OFFSET $2;
func (q *Queries) ListShaders4(ctx context.Context, arg ListShaders4Params) ([]ListShaders4Row, error) {
	rows, err := q.db.Query(ctx, listShaders4,
		arg.UserID,
		arg.AccessLevel,
		arg.Query,
		arg.SearchTagsOnly,
		arg.OrderBy,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShaders4Row
	for rows.Next() {
		var i ListShaders4Row
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.UserID,
			&i.AccessLevel,
			&i.PreviewImgUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Flags,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShadersDetailed = `-- name: ListShadersDetailed :many
SELECT sd.id, sd.title, sd.description, sd.user_id, 
    sd.access_level, sd.preview_img_url, sd.created_at, 
    sd.updated_at, sd.flags, sd.tags, sd.outputs
FROM shader_details sd
WHERE 
  (user_id = $1 OR $1 IS NULL) AND
  ($2::int2 IS NULL OR access_level = $2) AND 
  (
    $3::text IS NULL OR $3::text = '' OR
    (
      -- Search in title and tags combined
      ($4::boolean IS NULL OR $4::boolean = false)
      AND textsearchable_index_col @@ plainto_tsquery('english', $3::text)
      OR
      -- Search only in tags
      ($4::boolean IS NOT NULL AND $4::boolean = true)
      AND tags @@ plainto_tsquery('english', $3::text)
    )
  )
ORDER BY
    CASE WHEN $5::text = 'created_at_asc' THEN sd.created_at END ASC,
    CASE WHEN $5::text = 'created_at_desc' THEN sd.created_at END DESC,
    CASE WHEN $5::text = 'title_asc' THEN sd.title END ASC,
    CASE WHEN $5::text = 'title_desc' THEN sd.title END DESC
LIMIT $7::int
OFFSET $6::int
`

type ListShadersDetailedParams struct {
	UserID         pgtype.UUID
	AccessLevel    pgtype.Int2
	Query          pgtype.Text
	SearchTagsOnly pgtype.Bool
	OrderBy        pgtype.Text
	Off            int32
	Lim            pgtype.Int4
}

type ListShadersDetailedRow struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
	Outputs       []byte
}

func (q *Queries) ListShadersDetailed(ctx context.Context, arg ListShadersDetailedParams) ([]ListShadersDetailedRow, error) {
	rows, err := q.db.Query(ctx, listShadersDetailed,
		arg.UserID,
		arg.AccessLevel,
		arg.Query,
		arg.SearchTagsOnly,
		arg.OrderBy,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShadersDetailedRow
	for rows.Next() {
		var i ListShadersDetailedRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.UserID,
			&i.AccessLevel,
			&i.PreviewImgUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Flags,
			&i.Tags,
			&i.Outputs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShadersDetailedWithUser = `-- name: ListShadersDetailedWithUser :many
SELECT sd.id, sd.title, sd.description, sd.user_id, 
    sd.access_level, sd.preview_img_url, sd.created_at, 
    sd.updated_at, sd.flags, sd.tags, sd.outputs,sd.username
FROM shader_details_with_user sd
JOIN users u ON sd.user_id = u.id
WHERE 
  ($1::int2 IS NULL OR access_level = $1) AND 
  (
    $2::text IS NULL OR $2::text = '' OR
    (
      -- Search in title and tags combined
      ($3::boolean IS NULL OR $3::boolean = false)
      AND textsearchable_index_col @@ plainto_tsquery('english', $2::text)
      OR
      -- Search only in tags
      ($3::boolean IS NOT NULL AND $3::boolean = true)
      AND tags @@ plainto_tsquery('english', $2::text)
    )
  )
ORDER BY
    CASE WHEN $4::text = 'created_at_asc' THEN sd.created_at END ASC,
    CASE WHEN $4::text = 'created_at_desc' THEN sd.created_at END DESC,
    CASE WHEN $4::text = 'title_asc' THEN sd.title END ASC,
    CASE WHEN $4::text = 'title_desc' THEN sd.title END DESC
LIMIT $6::int
OFFSET $5::int
`

type ListShadersDetailedWithUserParams struct {
	AccessLevel    pgtype.Int2
	Query          pgtype.Text
	SearchTagsOnly pgtype.Bool
	OrderBy        pgtype.Text
	Off            pgtype.Int4
	Lim            pgtype.Int4
}

type ListShadersDetailedWithUserRow struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
	Outputs       []byte
	Username      string
}

func (q *Queries) ListShadersDetailedWithUser(ctx context.Context, arg ListShadersDetailedWithUserParams) ([]ListShadersDetailedWithUserRow, error) {
	rows, err := q.db.Query(ctx, listShadersDetailedWithUser,
		arg.AccessLevel,
		arg.Query,
		arg.SearchTagsOnly,
		arg.OrderBy,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShadersDetailedWithUserRow
	for rows.Next() {
		var i ListShadersDetailedWithUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.UserID,
			&i.AccessLevel,
			&i.PreviewImgUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Flags,
			&i.Tags,
			&i.Outputs,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShadersWithUser = `-- name: ListShadersWithUser :many
SELECT s.id, s.title, s.description, s.user_id, 
    s.access_level, s.preview_img_url, s.created_at, 
    s.updated_at, s.flags, s.tags, s.username
FROM shader_with_user s
WHERE 
  ($1::int2 IS NULL OR access_level = $1) AND 
  (
    $2::text IS NULL OR $2::text = '' OR
    (
      -- Search in title and tags combined
      ($3::boolean IS NULL OR $3::boolean = false)
      AND textsearchable_index_col @@ plainto_tsquery('english', $2::text)
      OR
      -- Search only in tags
      ($3::boolean IS NOT NULL AND $3::boolean = true)
      AND tags @@ plainto_tsquery('english', $2::text)
    )
  )
ORDER BY
    CASE WHEN $4::text = 'created_at_asc' THEN s.created_at END ASC,
    CASE WHEN $4::text = 'created_at_desc' THEN s.created_at END DESC,
    CASE WHEN $4::text = 'title_asc' THEN s.title END ASC,
    CASE WHEN $4::text = 'title_desc' THEN s.title END DESC
LIMIT $6::int
OFFSET $5::int
`

type ListShadersWithUserParams struct {
	AccessLevel    pgtype.Int2
	Query          pgtype.Text
	SearchTagsOnly pgtype.Bool
	OrderBy        pgtype.Text
	Off            int32
	Lim            pgtype.Int4
}

type ListShadersWithUserRow struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
	Username      string
}

func (q *Queries) ListShadersWithUser(ctx context.Context, arg ListShadersWithUserParams) ([]ListShadersWithUserRow, error) {
	rows, err := q.db.Query(ctx, listShadersWithUser,
		arg.AccessLevel,
		arg.Query,
		arg.SearchTagsOnly,
		arg.OrderBy,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListShadersWithUserRow
	for rows.Next() {
		var i ListShadersWithUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.UserID,
			&i.AccessLevel,
			&i.PreviewImgUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Flags,
			&i.Tags,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShader = `-- name: UpdateShader :one
UPDATE shaders 
SET title = COALESCE(NULLIF($3::TEXT,''), title),
    description = COALESCE($4, description),
    preview_img_url = COALESCE($5, preview_img_url),
    access_level = COALESCE($6, access_level),
    flags = COALESCE($7, flags),
    tags = COALESCE($8, tags)
WHERE id = $1 AND user_id = $2
RETURNING id, title, description, user_id, 
    access_level, preview_img_url, created_at, 
    updated_at, flags, tags
`

type UpdateShaderParams struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	Column3       string
	Description   pgtype.Text
	PreviewImgUrl pgtype.Text
	AccessLevel   int16
	Flags         int32
	Tags          pgtype.Text
}

type UpdateShaderRow struct {
	ID            uuid.UUID
	Title         string
	Description   pgtype.Text
	UserID        uuid.UUID
	AccessLevel   int16
	PreviewImgUrl pgtype.Text
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	Flags         int32
	Tags          pgtype.Text
}

func (q *Queries) UpdateShader(ctx context.Context, arg UpdateShaderParams) (UpdateShaderRow, error) {
	row := q.db.QueryRow(ctx, updateShader,
		arg.ID,
		arg.UserID,
		arg.Column3,
		arg.Description,
		arg.PreviewImgUrl,
		arg.AccessLevel,
		arg.Flags,
		arg.Tags,
	)
	var i UpdateShaderRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.UserID,
		&i.AccessLevel,
		&i.PreviewImgUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Flags,
		&i.Tags,
	)
	return i, err
}

const updateShaderPlaylist = `-- name: UpdateShaderPlaylist :exec
UPDATE shader_playlists
SET title = COALESCE(NULLIF($3::TEXT,''), title),
    access_level = COALESCE($4, access_level),
    description = COALESCE($5, description),
    tags = COALESCE($6, tags)
WHERE id = $1 AND user_id = $2
`

type UpdateShaderPlaylistParams struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	Column3     string
	AccessLevel int16
	Description pgtype.Text
	Tags        []string
}

func (q *Queries) UpdateShaderPlaylist(ctx context.Context, arg UpdateShaderPlaylistParams) error {
	_, err := q.db.Exec(ctx, updateShaderPlaylist,
		arg.ID,
		arg.UserID,
		arg.Column3,
		arg.AccessLevel,
		arg.Description,
		arg.Tags,
	)
	return err
}
